<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Home</title>
  <style>
@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");

/* ======================
   Design tokens
====================== */
:root{
  --bg-900:#0b0d12;
  --bg-850:#0e1117;
  --panel-800:#121722;
  --panel-750:#141a27;
  --panel-700:#162032;
  --panel-650:#1a2740;
  --text-100:#f5f7fb;
  --text-200:#e5eaf5;
  --text-400:#b8c1d9;
  --muted-500:#8892a7;
  --border:#23314b;

  --accent:#10a37f;              /* primary (kept) */
  --accent-2:#6ee7ff;            /* cyan */
  --accent-3:#7c3aed;            /* violet */

  --radius-lg:16px;
  --radius-md:12px;
  --radius-sm:10px;

  --shadow-1:0 8px 24px rgba(0,0,0,0.25);
  --shadow-2:0 12px 40px rgba(0,0,0,0.35);
  --glass:rgba(255,255,255,0.04);
  --glass-strong:rgba(255,255,255,0.06);

  --grad-accent:linear-gradient(135deg,var(--accent) 0%, var(--accent-2) 45%, var(--accent-3) 100%);
  --grad-surface:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.02));
}

/* ======================
   Base / Reset
====================== */
*{ box-sizing:border-box; }
html, body { height:100%; }
body{
  margin:0;
  font-family: Inter, 'Segoe UI', system-ui, -apple-system, Roboto, Arial, sans-serif;
  background:
    radial-gradient(1200px 800px at 10% -20%, rgba(124,58,237,0.12), transparent 55%),
    radial-gradient(1000px 600px at 120% 10%, rgba(16,163,127,0.14), transparent 50%),
    var(--bg-900);
  color:var(--text-100);
  display:flex;
  height:100vh;
  height:100dvh;      /* robust mobile viewport */
  overflow:hidden;    /* page itself never scrolls */
  min-height:0;
}

/* Custom scrollbars */
*::-webkit-scrollbar{ width:10px; height:10px; }
*::-webkit-scrollbar-thumb{
  background: linear-gradient(180deg, #2b3246, #1f2536);
  border-radius:10px;
  border:2px solid transparent;
  background-clip: padding-box;
}
*::-webkit-scrollbar-track{ background: transparent; }

/* ======================
   Sidebar
====================== */
.sidebar{
  width:260px;
  background: linear-gradient(180deg, #0f1420, #0d1018);
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  border-right:1px solid var(--border);
  backdrop-filter: blur(8px);
  flex:0 0 auto;
}

.chat-list{
  padding:1rem;
  flex:1;
  overflow-y:auto;
  min-height:0;
}

.chat-item{
  padding:0.9rem 1rem;
  margin-bottom:0.7rem;
  background: linear-gradient(180deg,#151b2a,#121825);
  border:1px solid rgba(255,255,255,0.05);
  border-radius: var(--radius-lg);
  cursor:pointer;
  transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease, filter .2s ease;
  box-shadow: 0 2px 10px rgba(0,0,0,0.25);
  color:var(--text-200);
}
.chat-item:hover{
  transform: translateY(-1px);
  filter:none;
  box-shadow: 0 8px 22px rgba(0,0,0,0.35);
  border-color: rgba(110,231,255,0.25);
}
.chat-add{
  background: linear-gradient(135deg, rgba(16,163,127,0.15), rgba(124,58,237,0.15));
  border:1px dashed rgba(110,231,255,0.35) !important;
}
.selected-chat{
  background: linear-gradient(135deg, rgba(16,163,127,0.18), rgba(124,58,237,0.18));
  border:1px solid rgba(110,231,255,0.45);
  box-shadow: 0 10px 28px rgba(16,163,127,0.18);
}

.delete-btn{
  margin-left:.6rem;
  background: transparent;
  border:1px solid rgba(255,255,255,0.15);
  color:#ff7979;
  font-weight:700;
  font-size:.85rem;
  padding: .35rem .65rem;
  border-radius:8px;
  cursor:pointer;
  transition: all .18s ease;
}
.delete-btn:hover{
  background:#ff6b6b;
  color:#fff;
  border-color:transparent;
  box-shadow: 0 6px 16px rgba(255, 107, 107, .35);
}

.profile{
  padding:.75rem .9rem;
  border-top:1px solid var(--border);
  display:flex;
  flex-direction:row;
  align-items:center;
  justify-content:flex-start;
  gap: .9rem;
  background: linear-gradient(180deg, #0e131f, #0b0f19);
}
.profile button{
  /* refined red gradient + glass highlights */
  --danger-1:#991b1b; /* deep red */
  --danger-2:#dc2626; /* mid red */
  --danger-3:#ef4444; /* bright red */

  background:
    radial-gradient(140% 180% at 30% 8%, rgba(255,255,255,.16), rgba(255,255,255,0) 55%),
    linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,0) 42%),
    linear-gradient(145deg, var(--danger-1) 0%, var(--danger-2) 48%, var(--danger-3) 100%);
  color:#fff;

  border:1px solid rgba(239,68,68,.55);
  border-radius:10px;
  padding:.75rem .85rem;
  font-weight:700;
  cursor:pointer;

  transition: filter .15s ease, transform .06s ease, box-shadow .2s ease, background .2s ease;
}

.profile button:hover{
  filter:brightness(.98);
  /* subtle hue shift for motion */
  background:
    radial-gradient(140% 180% at 30% 8%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
    linear-gradient(180deg, rgba(0,0,0,.15), rgba(0,0,0,0) 40%),
    linear-gradient(145deg, #a51f1f 0%, #e02424 48%, #ff5555 100%);
}

.profile button:active{
  transform: translateY(1px);
  box-shadow:
    0 8px 18px rgba(220,38,38,.3),
    inset 0 0 0 rgba(255,255,255,0);
}


/* ======================
   Main
====================== */
.main{
  flex:1 1 auto;
  display:flex;
  flex-direction:column;
  min-width:0;
  min-height:0; /* allow children to scroll instead of page */
}

header{
  padding:1rem;
  background: linear-gradient(135deg, rgba(16,163,127,0.16), rgba(124,58,237,0.16));
  text-align:center;
  font-weight:700;
  font-size:1.1rem;
  letter-spacing:.2px;
  border-bottom:1px solid var(--border);
  box-shadow: 0 6px 20px rgba(0,0,0,0.25);
  flex:0 0 auto;
}

.chat-container{
  flex:1 1 auto;
  overflow-y:auto;    /* main vertical scroller */
  padding:1.5rem;
  display:flex;
  flex-direction:column;
  gap:1.1rem;
  background:
    radial-gradient(900px 500px at 70% 0%, rgba(110,231,255,0.07), transparent 60%),
    radial-gradient(800px 600px at -10% 20%, rgba(124,58,237,0.08), transparent 60%);
  padding-bottom: calc(1.5rem + env(safe-area-inset-bottom, 0px));
  min-height:0;
}

.message{
  max-width:min(75%, 780px);
  padding:1rem 1.2rem;
  border-radius: var(--radius-lg);
  white-space:pre-wrap;
  word-wrap:break-word;
  line-height:1.55;
  font-size:.96rem;
  border:1px solid rgba(255,255,255,0.06);
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
  box-shadow: 0 8px 22px rgba(0,0,0,0.28);
  transition: box-shadow .2s ease, border-color .2s ease;
}
.message:hover{ border-color: rgba(110,231,255,0.25); }

.user{
  align-self:flex-end;
  color:#fff;
  background: linear-gradient(135deg, rgba(16,163,127,0.75), rgba(110,231,255,0.55));
  border:1px solid rgba(110,231,255,0.6);
  box-shadow: 0 10px 24px rgba(16,163,127,0.35);
}
.assistant{
  align-self:flex-start;
  background: linear-gradient(180deg, #141b2a, #0f1623);
  color: var(--text-200);
}

/* Images in messages */
.chat-image-bubble{
  display:inline-block;
  background: linear-gradient(180deg, #141b2a, #0f1623);
  border-radius: var(--radius-lg);
  box-shadow: 0 8px 22px rgba(0,0,0,0.28);
  border:1px solid rgba(110,231,255,0.18);
  padding:10px;
  margin:.5rem 0;
  align-self:flex-start;
  max-width:100%;
}
.chat-image-bubble img{
  display:block;
  max-width:100%;
  max-height:420px;
  width:auto;
  height:auto;
  border-radius:10px;
  object-fit:contain;
  margin:0 auto;
}

/* ======================
   Audio player
====================== */
.audio-player{
  background: linear-gradient(180deg, #0f1522, #0b1020);
  border: 1px solid rgba(110,231,255,0.18);
  border-radius: var(--radius-lg);
  padding:.85rem 1rem;
  display:flex;
  align-items:center;
  gap:1rem;
  max-width:420px;
  width:100%;
  margin-top:.5rem;
  box-shadow: var(--shadow-1);
}
.audio-player button{
  background: var(--grad-accent);
  border:none;
  border-radius:50%;
  width:42px; height:42px;
  color:white;
  font-size:1.15rem;
  display:flex; align-items:center; justify-content:center;
  cursor:pointer;
  transition: filter .15s ease, transform .06s ease;
  box-shadow: 0 8px 18px rgba(16,163,127,.35);
}
.audio-player button:hover{ filter:brightness(.95); }
.audio-player button:active{ transform: translateY(1px); }

.audio-player .progress-container{
  flex:1; height:6px;
  background: #1a2438;
  border-radius: 999px;
  overflow:hidden;
  cursor:pointer;
  position:relative;
}
.audio-player .progress{
  background: var(--grad-accent);
  height:100%; width:0%;
  transition: width .1s linear;
}

/* ======================
   Input area
====================== */
.input-area{
  display:flex;
  align-items:center;
  padding:1rem;
  padding-bottom: calc(1rem + env(safe-area-inset-bottom, 0px));
  border-top:1px solid var(--border);
  background: linear-gradient(180deg, #0e141f, #0b0f18);
  gap:.6rem;
  position:relative;
  box-shadow: 0 -10px 25px rgba(0,0,0,0.35);
  flex:0 0 auto;
}

.input-area input{
  flex:1;
  padding:.95rem 1rem;
  border:none;
  border-radius: var(--radius-md);
  background: linear-gradient(180deg, #1a2336, #141c2c);
  color:#fff;
  font-size:1rem;
  transition: box-shadow .2s ease, outline .2s ease, background .2s ease;
  border:1px solid rgba(255,255,255,0.06);
  min-width:0;
}
.input-area input::placeholder{ color: var(--muted-500); }
.input-area input:focus{
  outline:none;
  background: linear-gradient(180deg, #1d2740, #162033);
  box-shadow: 0 0 0 3px rgba(110,231,255,0.25);
  border-color: rgba(110,231,255,0.35);
}

.input-area button{
  background: var(--grad-accent);
  color: white;
  padding:.8rem 1.1rem;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-weight:700;
  transition: filter .15s ease, transform .06s ease;
  box-shadow: var(--shadow-1);
}
.input-area button:hover{ filter: brightness(.96); }
.input-area button:active{ transform: translateY(1px); }

/* Dropdown */
.dropdown-toggle{
  background: linear-gradient(180deg, #1a2336, #141c2c);
  border:1px solid rgba(255,255,255,0.08);
  color:white;
  padding:.6rem .9rem;
  border-radius:10px;
  cursor:pointer;
  font-size:1.1rem;
  transition: box-shadow .2s ease, border-color .2s ease, filter .15s ease;
}
.dropdown-toggle:hover{
  filter: brightness(1.03);
  border-color: rgba(110,231,255,0.3);
  box-shadow: 0 6px 20px rgba(0,0,0,0.25);
}

.dropdown-menu{
  position:absolute;
  bottom:65px; /* desktop default */
  left:12px;
  background: linear-gradient(180deg, #0f1522, #0b1020);
  border:1px solid rgba(110,231,255,0.22);
  border-radius:12px;
  padding:.8rem 1rem;
  display:none;
  flex-direction:column;
  gap:.75rem;
  z-index:999;
  box-shadow: var(--shadow-2);
  max-width:min(90vw, 420px);
}
.dropdown-menu label{
  display:flex; justify-content:space-between; align-items:center;
  font-size:.95rem; color: var(--text-200);
}
.dropdown-menu input[type="checkbox"]{
  transform: scale(1.2);
  accent-color: var(--accent);
}

/* Mic quick button */
.mic-button{
  background: linear-gradient(180deg, #1a2336, #141c2c);
  border:1px solid rgba(255,255,255,0.08);
  color:white;
  padding:.6rem;
  border-radius:50%;
  cursor:pointer;
  font-size:1.1rem;
  transition: filter .15s ease, border-color .2s ease;
}
.mic-button:hover{
  filter: brightness(1.03);
  border-color: rgba(110,231,255,0.3);
}

/* ======================
   Responsive
====================== */
@media (max-width:1024px){
  .sidebar{ width:200px; }
  .chat-item{ font-size:.9rem; padding:.6rem .85rem; }
  .dropdown-toggle,.mic-button,.input-area button{ font-size:.9rem; }
  .input-area input{ font-size:.9rem; }
  .message{ max-width:min(85%, 720px); }
  .chat-image-bubble img{ max-height:360px; }
}

/* Mobile: sidebar becomes top bar; chats left, profile/logout right */
@media (max-width:768px){
  body{ flex-direction:column; }

  .sidebar{
    width:100%; height:auto;
    flex-direction:row;
    align-items:center;
    justify-content:space-between;     /* chat list left, profile right */
    overflow:visible;
    border-right:none; border-bottom:1px solid var(--border);
    padding:.5rem .6rem;
    gap:.5rem;
    flex:0 0 auto;
  }

  .chat-list{
    display:flex; flex-direction:row; flex-wrap:nowrap;
    gap:.5rem; padding:0; margin:0;
    overflow-x:auto; overflow-y:hidden; /* horizontal tabs */
    scroll-snap-type:x proximity;
    flex:1 1 auto; min-width:0;
  }
  .chat-item{
    flex-shrink:0; white-space:nowrap; margin:0;
    scroll-snap-align:start;
  }

  .profile{
    order:2; flex:0 0 auto;
    border-top:none; border-left:1px solid var(--border);
    padding:.4rem .6rem .4rem .8rem;
    margin-left:.5rem;
    background: transparent; /* blend into top bar */
  }

  .main{
    flex:1 1 auto; display:flex; flex-direction:column; min-height:0; width:100%;
  }
  header{ font-size:1rem; padding:.75rem; }

  .chat-container{ padding:1rem .75rem; font-size:.9rem; gap:.9rem; }
  .message{
    font-size:.9rem; padding:.85rem; border-radius:14px; max-width:92%;
  }

  .audio-player{ max-width:100%; }
  .chat-image-bubble img{ max-height:320px; }

  .input-area{
    flex-wrap:wrap; gap:.5rem; padding:.75rem;
    padding-bottom: calc(.75rem + env(safe-area-inset-bottom, 0px));
  }
  .input-area input{ width:100%; padding:.75rem; border-radius:10px; }
  .input-area button,.dropdown-toggle,.mic-button{
    padding:.6rem; border-radius:8px; font-size:.9rem;
  }

  /* Dropdown opens upward from top bar on mobile */
  .dropdown-menu{ left:auto; right:.5rem; bottom:calc(100% + 8px); }
}

@media (max-width:520px){
  .chat-container{ padding:.85rem .65rem; }
  .message{ max-width:100%; }
  .chat-image-bubble img{ max-height:260px; }
  .mic-button{ padding:.5rem; }
  .audio-player button{ width:38px; height:38px; font-size:1rem; }
}

/* ======================
   Mic overlay (kept)
====================== */
.mic-overlay{
  position:fixed; inset:0; display:none;
  align-items:center; justify-content:center;
  background: rgba(7, 10, 18, 0.72);
  backdrop-filter: blur(4px);
  z-index:2000; color:var(--text-100);
  font-family: inherit;
  --level:0;
}
.mic-overlay.active{ display:flex; }
.mic-center{ display:grid; place-items:center; gap:1rem; text-align:center; padding:1rem; }
.mic-status{ font-size:.95rem; opacity:.9; }

.mic-visual{ position:relative; width:180px; height:180px; }
.mic-ball{
  --base: var(--accent);
  position:absolute; inset:0; margin:auto;
  width:140px; height:140px; border-radius:50%;
  background: radial-gradient(60% 60% at 30% 30%, #16b28b 0%, #0e8a6c 45%, #0c6b55 100%);
  box-shadow: 0 8px 30px rgba(16,163,127,0.35), inset 0 0 18px rgba(255,255,255,0.06);
  border:1px solid rgba(16,163,127,0.35);
  animation: mic-breathe 2.8s ease-in-out infinite;
  transform: translateY(calc(-6px * var(--level))) scale(calc(.88 + (.28 * var(--level))));
  transition: transform 80ms linear;
}
.mic-visual::before, .mic-visual::after{
  content:""; position:absolute; inset:0; margin:auto;
  width:140px; height:140px; border-radius:50%;
  background: radial-gradient(circle, rgba(16,163,127,0.25), rgba(16,163,127,0) 60%);
  animation: mic-ripple 2.8s ease-out infinite; pointer-events:none;
}
.mic-visual::after{ animation-delay:1.4s; filter: blur(1px); }

.mic-actions{
  position:fixed; left:50%; bottom:24px; transform:translateX(-50%);
  display:flex; gap:.75rem; padding:0 1rem;
}
.mic-btn{
  border:none; border-radius:12px; padding:.85rem 1.2rem; font-weight:700;
  cursor:pointer; transition: filter .15s ease, transform .05s ease; box-shadow: var(--shadow-1);
}
.mic-btn:active{ transform: translateY(1px); }
.mic-btn.cancel{ 
  --danger-1:#991b1b; 
  --danger-2:#dc2626;
  --danger-3:#ef4444; 

  background:
    radial-gradient(140% 180% at 30% 8%, rgba(255,255,255,.16), rgba(255,255,255,0) 55%),
    linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,0) 42%),
    linear-gradient(145deg, var(--danger-1) 0%, var(--danger-2) 48%, var(--danger-3) 100%);
  color:#fff;

  border:1px solid rgba(239,68,68,.55);
  border-radius:10px;
  padding:.75rem .85rem;
  font-weight:700;
  cursor:pointer;

  transition: filter .15s ease, transform .06s ease, box-shadow .2s ease, background .2s ease;}
.mic-btn.cancel:hover{ filter: brightness(.92); }
.mic-btn.submit{ background: linear-gradient(135deg, rgba(9, 250, 129, 0.75), rgba(110,231,255,0.55)); color:#fff; }
.mic-btn.submit:hover{ filter: brightness(.95); }

/* Animations */
@keyframes mic-breathe{
  0%{ transform: translateY(0) scale(.92); }
  50%{ transform: translateY(-4px) scale(1.02); }
  100%{ transform: translateY(0) scale(.92); }
}
@keyframes mic-ripple{
  0%{ transform: scale(1); opacity:.5; }
  70%{ transform: scale(1.35); opacity:.12; }
  100%{ transform: scale(1.5); opacity:0; }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce){
  *{ animation:none !important; transition:none !important; scroll-behavior:auto !important; }
}


  </style>
</head>
<body>

  <!-- Sidebar -->
  <div class="sidebar">
    <div class="chat-list">
      <div class="chat-item chat-add" onclick="addNewChat()">New chat</div>
    </div>
    <div class="profile">
      <button onclick="logout()">Log out</button>
      <div>{{username}}</div>      
    </div>
  </div>

  <!-- Main Content -->
  <div class="main">
    <header>Book Retreival GPT</header>

    <div class="chat-container" id="chat">
      <!-- <div class="message assistant">Hello! How can I help you today?</div> -->
    </div>

    <div class="input-area">
      <!-- Dropdown -->
      <div>
        <button class="dropdown-toggle" onclick="toggleDropdown()">â˜°</button>
        <div class="dropdown-menu" id="dropdownMenu">
          <label>
            Return Audio
            <input type="checkbox" id="toggleAudio">
          </label>
          <label>
            Return Picture
            <input type="checkbox" id="togglePicture">
          </label>
        </div>
      </div>

      <input type="text" id="userInput" placeholder="Send a message..." />
      <button class="mic-button" onclick="startMic()">ðŸŽ¤</button>
      <button onclick="sendMessage()">Send</button>

      <!-- Microphone -->
      
    </div>
  </div>

  <div class="mic-overlay" id="micOverlay">
  <div class="mic-center">
    <div class="mic-visual">
      <div class="mic-ball"></div>
    </div>
    <div class="mic-status" id = "micStatus">Listeningâ€¦ speak now</div>
    <br>
    <div class = "mic-status" id = "spokenText"></div>
  </div>

  <div class="mic-actions">
    <button class="mic-btn cancel"  onclick="cancelMic()">Cancel</button>
    <button class="mic-btn submit"  onclick="stopMic()">Submit</button>
  </div>
</div>

  <script>
    let micStatus = 0;
    let waitingForMic = false;
    let mediaRecorder = null;
    let audioChunks = [];
    let micStream = null;
    var currentChatId = -1;
    getChatsHistory();
    function logout() {
      document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
      location.reload();
    }
    function sendMessage() {
      const input = document.getElementById("userInput");
      const text = input.value.trim();
      input.value = "";
      if (text === "") return;

      const chat = document.getElementById("chat");

      const userMessage = document.createElement("div");
      userMessage.className = "message user";
      userMessage.textContent = text;
      chat.appendChild(userMessage);

      const assistantMessage = document.createElement("div");
      assistantMessage.className = "message assistant";
      assistantMessage.textContent = "Thinking...";
      chat.appendChild(assistantMessage);

      fetch('/api/add_message', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          id: currentChatId,
          content: text,
          image: document.getElementById("togglePicture").checked,
          sound: document.getElementById("toggleAudio").checked
        })
      }).then(response => {
        if (!response.ok) {         
          //userMessage.remove();
          throw new Error('Network response was not ok');
        }
        return response.json();
      }).then(data => {
        console.log('Message sent successfully:', data);
        
        assistantMessage.textContent = data.response.replace(/\[image\].*?\[\/image\]/, "").replace(/\[audio\].*?\[\/audio\]/, "").trim() || "No response from server.";
        chat.appendChild(assistantMessage);

        if (data.response && data.response.includes("[image]")) {
          const imgStart = data.response.indexOf("[image]") + 7;
          const imgEnd = data.response.indexOf("[/image]");
          const imgSrc = data.response.substring(imgStart, imgEnd);          

          chat.appendChild(createImageBubble(imgSrc));
        }  
        if (data.response && data.response.includes("[audio]")) {
          const audioStart = data.response.indexOf("[audio]") + 7;
          const audioEnd = data.response.indexOf("[/audio]");
          const audioSrc = data.response.substring(audioStart, audioEnd);          

          chat.appendChild(createAudioPlayer(audioSrc));
        }                 
        chat.scrollTop = chat.scrollHeight;

      }).catch(error => {
        console.error('There was a problem with the fetch operation:', error);
        //userMessage.remove();
        assistantMessage.textContent = "Error";
      });

      
      /*let response = "This is a static response.";
      if (document.getElementById("toggleAudio").checked) {
        response += " ðŸ”Š [Audio enabled]";
      }
      if (document.getElementById("togglePicture").checked) {
        response += " ðŸ–¼ï¸ [Picture enabled]";
      };*/
      
    }

    function toggleDropdown() {
      const menu = document.getElementById("dropdownMenu");
      menu.style.display = menu.style.display === "flex" ? "none" : "flex";
    }

    // Close dropdown if clicked outside
    document.addEventListener("click", function (e) {
      const menu = document.getElementById("dropdownMenu");
      const toggle = document.querySelector(".dropdown-toggle");
      if (!menu.contains(e.target) && !toggle.contains(e.target)) {
        menu.style.display = "none";
      }
    });

    function addNewChat(name = "Chat!", id = 0, isNew = true) {    
      const chatList = document.querySelector(".chat-list");
      const newChatItem = null;
      if(!isNew)
      {
        const newChatItem = document.createElement("div");
        newChatItem.className = "chat-item";
        newChatItem.textContent = name;

        newChatItem.onclick = function() {
          selectChat(newChatItem, id);
        };

        const deleteButton = document.createElement("button");
        deleteButton.textContent = "Delete";
        deleteButton.classList.add("delete-btn");
        deleteButton.onclick = function(event) {
          event.stopPropagation();
          deleteChat(newChatItem, id);
        };
        newChatItem.appendChild(deleteButton);

        chatList.appendChild(newChatItem);
      }
      
      
      if(!isNew) return;

      const chatname = prompt("Enter a chat name:");
      if (!chatname) {
        alert("Chat name is required.");
        return;
      }
      name = chatname;

      fetch('/api/add_chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          username: '{{username}}',
          chatname: name
        })
      }).then(response => {
        if (!response.ok) {
          chatList.removeChild(newChatItem);
        }
        return response.json();
      }).then(data => {
        console.log('Chat added successfully:', data);

        const newChatItem = document.createElement("div");
        newChatItem.className = "chat-item";
        newChatItem.textContent = name;

        const deleteButton = document.createElement("button");
        deleteButton.textContent = "Delete";
        deleteButton.classList.add("delete-btn");
        deleteButton.onclick = function(event) {
          event.stopPropagation();
          deleteChat(newChatItem, data.id);
        };
        newChatItem.appendChild(deleteButton);

        newChatItem.onclick = function() {
          selectChat(newChatItem, data.id);
        };
        chatList.insertBefore(newChatItem, chatList.children[1]);
        selectChat(newChatItem, data.id);
      }).catch(error => {
        console.error('There was a problem with the fetch operation:', error);
        chatList.removeChild(newChatItem);
      });

      
    }

    function deleteChat(chat, id) {
      if (!confirm("Are you sure you want to delete this chat?")) return;

      fetch('/api/delete_chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          id: id
        })
      }).then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      }).then(data => {
        console.log('Chat deleted successfully:', data);
        chat.remove();
        const chatContainer = document.getElementById("chat");
        chatContainer.innerHTML = ""; 

        location.reload();

      }).catch(error => {
        console.error('There was a problem with the fetch operation:', error);
      });
    }

    function selectChat(chat, id){
      if(currentChatId === id) return;
      currentChatId = id;
      const chatContainer = document.getElementById("chat");
      chatContainer.innerHTML = ""; 
      console.log("Selected chat ID:", currentChatId);
      const chatItems = document.querySelectorAll(".chat-item");
      chatItems.forEach(item => {
        if(item !== chat) {
          item.classList.remove("selected-chat");
        }
        else {
          item.classList.add("selected-chat");
        }
      });

      fetch('/api/get_chat_info', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          id: id
        })
      }).then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      }).then(data => {
        
        chatContainer.innerHTML = ""; 
        data.messages.forEach(message => {
          const messageDiv = document.createElement("div");
          messageDiv.className = "message " + (message.role === "user" ? "user" : "assistant");
          console.log("Message content:", message.content);
          messageDiv.textContent = message.content.replace(/\[image\].*?\[\/image\]/, "").replace(/\[audio\].*?\[\/audio\]/, "").trim();
          chatContainer.appendChild(messageDiv);

          if (message.content && message.content.includes("[image]")) {
          const imgStart = message.content.indexOf("[image]") + 7;
          const imgEnd = message.content.indexOf("[/image]");
          const imgSrc = message.content.substring(imgStart, imgEnd);    

          
          chatContainer.appendChild(createImageBubble(imgSrc));         
          } 

          if (message.content && message.content.includes("[audio]")) {
          const audioStart = message.content.indexOf("[audio]") + 7;
          const audioEnd = message.content.indexOf("[/audio]");
          const audioSrc = message.content.substring(audioStart, audioEnd);    

          
          chatContainer.appendChild(createAudioPlayer(audioSrc));         
          } 
        });
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }).catch(error => {
        console.error('There was a problem with the fetch operation:', error);
      });
    }

    function getChatsHistory()
    {
      fetch('/api/get_chats', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          username: '{{username}}'
        })
      }).then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      }).then(data => {
        const chats = data.chats;
            chats.forEach(chat => {
          addNewChat(chat.chat_name, chat.id, false);
            });
            const chatItems = document.querySelectorAll(".chat-item");
            if(chatItems.length > 1) {
              const firstChat = chatItems[1];
              selectChat(firstChat, chats[0].id);
              console.log("Selected chat ID:", chats[0].id);
              console.log("Selected chat name:", firstChat.textContent);
            }
      }).catch(error => {
        console.error('There was a problem with the fetch operation:', error);
      });
    }

    function toggleAudioPlayback(button) {
  const player = button.closest(".audio-player");
  const audio = player.querySelector("audio");
  const progress = player.querySelector(".progress");

  if (audio.paused) {
    audio.play();
    button.textContent = "â¸ï¸";
  } else {
    audio.pause();
    button.textContent = "â–¶ï¸";
  }

  audio.ontimeupdate = () => {
    const percentage = (audio.currentTime / audio.duration) * 100;
    progress.style.width = percentage + "%";
  };

  audio.onended = () => {
    button.textContent = "â–¶ï¸";
    progress.style.width = "0%";
  };
}

function seekAudio(event, container) {
  const audio = container.closest(".audio-player").querySelector("audio");
  const rect = container.getBoundingClientRect();
  const offsetX = event.clientX - rect.left;
  const percentage = offsetX / rect.width;
  audio.currentTime = percentage * audio.duration;
}

function createAudioPlayer(base64Audio) {
  const wrapper = document.createElement("div");
  wrapper.className = "audio-player";

  const button = document.createElement("button");
  button.textContent = "â–¶ï¸";
  button.onclick = function () {
    toggleAudioPlayback(button);
  };

  const progressContainer = document.createElement("div");
  progressContainer.className = "progress-container";
  progressContainer.onclick = function (e) {
    seekAudio(e, progressContainer);
  };

  const progress = document.createElement("div");
  progress.className = "progress";
  progressContainer.appendChild(progress);

  const audio = document.createElement("audio");
  audio.src = "data:audio/wav;base64," + base64Audio;
  audio.preload = "auto";

  wrapper.appendChild(button);
  wrapper.appendChild(progressContainer);
  wrapper.appendChild(audio);

  return wrapper;
}

function createImageBubble(base64Image) {
const imageBubble = document.createElement("div")
imageBubble.className = "chat-image-bubble";
const imageElement = document.createElement("img");
imageElement.src = "data:image/png;base64," + base64Image;
imageElement.style.maxWidth = "100%";
imageElement.style.borderRadius = "12px";
imageBubble.appendChild(imageElement);
return imageBubble;
}

function stopMicrophone() {
  if(waitingForMic) return;
  if (micStatus === 0) return;

  mediaRecorder?.stop()
  document.getElementById("micOverlay").classList.remove("active");
  micStatus = 0;
}
function startMic()
{
  start().catch(e => { console.error(e); stop(); });
  document.getElementById("micOverlay").classList.add("active");
}
function stopMic()
{
  stop();
  document.getElementById('userInput').value += out.textContent;
  document.getElementById("micOverlay").classList.remove("active");
}

function cancelMic()
{
  stop();
  document.getElementById("micOverlay").classList.remove("active");
}
async function toggleMicrophone() {
  if(waitingForMic) return;
  try {
    if (micStatus === 0) {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

      

      document.getElementById("micOverlay").classList.add("active");
      document.getElementById("micStatus").textContent = "Listeningâ€¦ speak now";

      const mimeType = MediaRecorder.isTypeSupported("audio/webm;codecs=opus")
        ? "audio/webm;codecs=opus"
        : MediaRecorder.isTypeSupported("audio/webm")
        ? "audio/webm"
        : "";

      mediaRecorder = new MediaRecorder(micStream, mimeType ? { mimeType } : undefined);
      audioChunks = [];

      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) audioChunks.push(e.data);
      };

      mediaRecorder.start();
      micStatus = 1;
      return;
    }

    if (!mediaRecorder) return;

    const base64 = await stopRecordingToBase64();
    console.log("Base64 audio:", base64);
    document.getElementById("micStatus").textContent = "Processing audio...";
    document
    micStatus = 0;
    waitingForMic = true;

    fetch('/api/audio_to_text', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        audio: base64,
      })
    }).then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    }).then(data => {
      waitingForMic = false;
      console.log('Message sent successfully:', data);
      document.getElementById('userInput').value = data.text;
      document.getElementById("micOverlay").classList.remove("active");
    }).catch(error => {
      waitingForMic = false;
      console.error('There was a problem with the fetch operation:', error);
      document.getElementById('userInput').value = 'Error';
      document.getElementById("micOverlay").classList.remove("active");
    });

  } catch (err) {
    waitingForMic = false;
    console.error("Mic error:", err);
    document.getElementById('userInput').value = 'Error';
    document.getElementById("micOverlay").classList.remove("active");
    cleanupMic();
  }
}


function stopRecordingToBase64() {
  return new Promise((resolve, reject) => {
    try {
      mediaRecorder.onstop = async () => {
        try {
          const blob = new Blob(audioChunks, { type: mediaRecorder.mimeType || "audio/webm" });

          const el = document.getElementById("audioPlayback");
          if (el) el.src = URL.createObjectURL(blob);

          const reader = new FileReader();
          reader.onloadend = () => {
            const base64 = reader.result.split(",")[1];
            audioChunks = [];
            cleanupMic();
            resolve(base64);
          };
          reader.readAsDataURL(blob);
        } catch (e) {
          cleanupMic();
          reject(e);
        }
      };

      mediaRecorder.stop();
    } catch (e) {
      cleanupMic();
      reject(e);
    }
  });
}

function cleanupMic() {
  try {
    if (micStream) {
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }
  } catch {}
  mediaRecorder = null;
  audioChunks = [];
}
  let committed = "";
  let partial = "";
  let ws, ctx, node, src, stream;
  let running = false;
  const out = document.getElementById("spokenText");

  function safeSend(buf){
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    if (ws.bufferedAmount > 1_000_000) return; // drop if backpressure
    ws.send(buf);
  }

  async function start() {
    if (running) return;
    running = true;
    out.textContent = "";
    committed = "";
    partial = "";

    // 1) connect WS first
    const proto = location.protocol === "https:" ? "wss" : "ws";
    ws = new WebSocket(`${proto}://${location.host}/stt`);

    await new Promise((res, rej) => {
      ws.onopen = res;
      ws.onerror = rej;
    });

    ws.onmessage = async (e) => { 
      try {
    const raw = e.data instanceof Blob ? await e.data.text() : e.data;
    const msg = typeof raw === "string" ? JSON.parse(raw) : raw;

    if (msg.type === "transcript.partial") {
      partial += msg.text;
    } else if (msg.type === "transcript.final") {
      committed += msg.text + " ";
      partial = "";
    } else {
      console.log("WS other:", msg);
      return;
    }

      out.textContent = committed + partial;
    } catch (err) {
      console.warn("Non-JSON WS message:", e.data, err);
    }
    }

    ws.onclose = (e) => {
      console.log("WS closed",
    "code:", e.code,        // e.g., 1000 = normal, 1006 = abnormal
    "reason:", e.reason,
    "clean:", e.wasClean
  );
      stop(); // stop producer immediately when socket closes
    };
    ws.onerror = (e) => {
  console.log("WS error:", e?.message || e);
};

    // 2) audio graph + external worklet
    ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
    await ctx.audioWorklet.addModule("/static/pcm16-writer.js");

    node = new AudioWorkletNode(ctx, "pcm16-writer", { processorOptions: { frameSize: 1600 }});
    node.port.onmessage = (ev) => safeSend(ev.data); // ArrayBuffer (binary)

    stream = await navigator.mediaDevices.getUserMedia({
      audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true }
    });
    src = ctx.createMediaStreamSource(stream);
    src.connect(node);
    await ctx.resume();
    console.log("Streamingâ€¦");
  }

  function stop() {
    if (!running) return;
    running = false;

    

    try { if (src && node) src.disconnect(node); } catch {}
    try { if (node) node.port.onmessage = null; } catch {}
    try { if (ctx && ctx.state !== "closed") ctx.close(); } catch {}
    try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch {}

    src = node = stream = null; ctx = null;

    try { if (ws && ws.readyState === WebSocket.OPEN) ws.close(1000, "client stop"); } catch {}
    ws = null;
  }
  </script>

</body>
</html>
